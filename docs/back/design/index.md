---
date: 2024-04-10 18:50:29
publish: true
tag: 设计模式
---
<!-- markdownlint-disable-file -->

# 设计模式

    设计和开发面向对象软件是非常困难的，而设计和开发可以复用的面向对象软件则更加困难
通常认为，一个易于维护的系统，就是复用率较高的系统，而一个复用率较的系统又是一个好维护的系统，但实际上，软件的可维护（Manitainability）和可复用性（Reusability）是两个独立的目标面向对象**设计原则**就是为解决这个问题而诞生的，而设计原则又是设计式诞生的依据，因此在了解设计模式之前，我们有必要先了解一下设计原则

## 简介
 常用的设计原则有7个，他们之间互相依赖，互相补充
 原则|简介
 -|-
 单一职责原则| 类的职责要单一
 开闭原则|对扩展开放，对修改关闭
 里氏代换原则|可以接受基类对象的地方，应该可以接受子类对象
 依赖倒转原则|针对接口编程，依赖于抽象而不依赖于具体
 接口隔离原则|使用多个隔离的接口，比使用单个接口要好
 迪米特法则|一个类对自己依赖的类知道的越少越好
 合成复用原则|尽量使用合成/聚合的方式，而不是使用继承   
 

 ## 单一职责原则
 单一职责原则（Single Responsibility Principle）规定一个类应该**有且仅有一个**引起它变化的原因，否则类应该被拆分。，它用于控制粒度大小。
 
 ### 分析
 在面向对象编程中，如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类的其他职责，也可能会导致该类的行为异常。

 类的职责包括两方面，数据职责和行为职责，数据职责就是类的属性，行为职责就是类的方法，最好将不同的变化原因分装在不同的类中

 单一职责是实现 高内聚，低耦合的指导方针，它是最简单的设计原则，但又最难运用，因为很难找到不同的职责并将其分离

## 开闭原则
 开闭原则（Open Closed Principle）规定一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。是最重要的面向对象设计原则
 ### 分析
 任何软件都会面临一个问题，就是需求会随之时间的推移而变化，因此当产生新需求的时候，我们应该尽量不修改原来的代码，而是对原有系统进行拓展，这样才能使得软件在拥有适应性和灵活性的同时，具备较好的稳定性和延续性


为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键，设计一个相对稳定的抽象层，在通过具体的类来拓展，如果需要修改系统的行为，只需要新增具体的实现类，而无需修改已有代码，从而达到开闭原则的要求

## 里氏代换原则
 里氏代换原则（Liskov Substitution Principle）规定所有引用基类的地方必须能透明地使用其子类的对象，里氏代换原则是实现开闭原则的重要方式之一，它描述了类继承关系中子类对象可以替换程序中父类对象的位置而不产生错误的结果，里氏代换原则是面向对象设计的基本原则之一，它确保了继承层次的稳定，是实现开闭原则的具体手段之一。

### 分析
说白了就是，父类能行，子类就能行，子类能行，父类不一定能行，想想雨化田的经典台词（东厂管的了的我要管，东厂管不了的我还要管）

## 依赖倒置原则
 依赖倒置原则（Dependence Inversion Principle）要求程序要面向接口编程，不要面向实现编程。

 ### 分析
 如果说开闭原则是面向对象设计的目标，那依赖倒置就是实现面向对象设计的主要机制。

 在程序中尽量使用抽象编程，而将具体类写在配置文件里，这样就可以通过配置文件修改程序的行为，而不影响原来的代码，也就是推迟对具体类的定义，有助于设计出能够快速变更的解决方案，以应对项目变化的需求

 ### 两个概念
 #### 1. 类之间的耦合
 两个类通常会发生三种耦合关系
 * 零耦合： 两个类没有任何耦合
 * 具体耦合：一个类对另一个具体类的实例直接引用
 * 抽象耦合：两个类中至少有一个是抽象的，这样会更灵活

依赖倒置要求客户端依赖于抽象耦合
#### 2. 依赖注入
 依赖注入（Dependency Injection）是实现依赖倒置原则的主要方法，依赖注入会尽可能地避免具体类的使用，它通过接口或抽象类来定义依赖关系，而通过具体类的实现类来注入依赖关系

 ## 接口隔离原则
 接口隔离原则（Interface Segregation Principle）要求客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上

 另一中定义是：一旦一个接口太大，就要将其分割成一些细节更小的接口

 ### 分析
 如果把这个接口理解成java中的interface的话，那就是说接口尽量要小，满足单一职责

 如果是把接口理解成某个角色，接口的划分实际就是类的划分，每个类要


## 合成复用原则
 合成复用原则（Composite Reuse Principle）要求在软件复用时，要尽量使用合成/聚合的方式，而不是使用继承

 合成复用原则和里氏代换原则是两种不同的思路，合成复用原则强调的是在系统复用时，尽量使用组合或者聚合等关联关系来实现，而不是使用继承关系来实现。
 ### 分析
Java中，一个类想使用另一个类的方法，可以通过继承或者依赖的方式来实现，而合成复用原则则建议使用依赖的方式来实现，即通过组合的方式来实现。

下面我们来分析一下这两中情况的区别

**继承**：
* 子类可以随意修改父类的实现细节，破坏了父类的封装性。
* 父类的某些实现细节对子类来说是可见的，这种复用称为"白箱"复用。
* 父类如果改变的话，子类可能也要改变。
* 从父类继承而来的实现是静态的，不能在运行时改变，不够灵活
* 只能在有限的环境中使用（类没有被final修饰）

**组合**：
* 方法的实现细节是不可见的，这种复用称为"黑箱"复用。
* 相对继承来说，耦合较低。
* 可以在运行时动态进行

那合成复用和里氏代换不就冲突了吗，到底是要继承还是组合 damn！

我认为：一个方法的诞生有这么几个阶段，被定义，被实现，被使用。

定义在抽象类中，实现在具体类中，通过合成复用被使用

## 迪米特法则
 迪米特法则（Law of Demeter）要求一个对象应该对其他对象保持最少的了解，即一个对象应该对自己需要交互的对象有尽可能少的了解，尽量降低类之间的耦合。
   
### 分析
迪米特法则主要用于实现低耦合，可分为狭义法则和广义法则
#### 狭义法则
不允许出现`a.b.method()` 这种情况，只能有一个`.`，显然这样可以使一个系统的**局部**设计简化，但同时，也会造成通信效率低
#### 广义法则
对象之间的信息流量，流向，以及信息的影响的控制，主要是对信息的隐藏，信息隐藏可以使各个子系统之间脱藕，从而允许每个子系统被独立开发，优化，使用，同时还可以促进软件的复用，一个系统越大，信息隐藏就越重要

迪米特法则主要用途在于控制信息过载，在运用迪米特法则时，注意一下几点

1. 在类的划分上，尽量创建松耦合的类
2. 降低成员变量和成员函数的访问权限
3. 只要有可能，一个类应当设计为不变类
4. 对其他对象的引用应当降到最低
